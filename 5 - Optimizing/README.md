# Optimizing

## 一、课程概述
- **课程主题**：SQL查询优化（时间/空间优化）与并发处理，核心围绕“索引设计”“数据库压缩”“事务与并发控制”三大核心展开。
- **主讲人**：Carter Zenke、David J. Malan（哈佛大学）
- **核心工具**：SQLite，示例数据库`movies.db`（IMDb电影数据，含40万+电影、140万+演员、20万+评分）、`bank.db`（银行账户转账示例）
- **课程目标**：掌握索引创建与优化、数据库空间清理、事务ACID特性、并发控制机制，解决大规模数据查询慢和多用户并发操作冲突问题

## 二、查询优化核心：索引（Index）
### 1. 索引定义与作用
- 索引是数据库中用于**加速数据检索**的特殊数据结构，类似书籍目录，避免全表扫描（逐行查找）。
- 核心特性：
  - 主键列（PRIMARY KEY）会自动创建索引（SQLite默认），普通列需手动创建。
  - 可通过`EXPLAIN QUERY PLAN + 查询语句`验证索引是否被使用。
- 语法：
  - 创建索引：`CREATE INDEX "索引名" ON "表名" ("列名");`
  - 删除索引：`DROP INDEX "索引名";`

### 2. 基础索引示例
- 场景：查询电影《Cars》的信息（未创建索引时需全表扫描）。
  1. 开启查询计时：`.timer on`（SQLite命令，显示查询耗时）。
  2. 未创建索引时查询：`SELECT * FROM "movies" WHERE "title" = 'Cars';`（耗时约0.1秒）。
  3. 创建标题列索引：`CREATE INDEX "title_index" ON "movies" ("title");`。
  4. 再次查询：耗时显著降低（约为原耗时的1/8），索引直接定位匹配行。

### 3. 跨表索引与覆盖索引
#### （1）跨表索引场景
查询演员“Tom Hanks”主演的所有电影（需关联`people`“演员表”、`stars`“关联表”、`movies`“电影表”）：
- 原查询（未建索引）：需扫描`people`和`stars`表，效率低。
- 优化步骤：
  1. 为`people`表的`name`列创建索引（快速查找演员ID）：`CREATE INDEX "name_index" ON "people" ("name");`。
  2. 为`stars`表的`person_id`列创建索引（快速查找演员关联的电影ID）：`CREATE INDEX "person_index" ON "stars" ("person_id");`。
  3. 验证：`EXPLAIN QUERY PLAN`显示所有查询均通过索引完成，无全表扫描。

#### （2）覆盖索引（Covering Index）
- 定义：索引中包含查询所需的所有信息，无需额外查询原表，进一步提升效率。
- 示例：优化`stars`表索引，包含`person_id`（查询条件）和`movie_id`（查询结果）：
  ```sql
  DROP INDEX "person_index";  -- 删除原索引
  CREATE INDEX "person_index" ON "stars" ("person_id", "movie_id");  -- 覆盖索引
  ```
- 优势：查询时直接从索引获取`movie_id`，无需访问`stars`原表，效率再提升一个量级。

### 4. 索引的权衡
#### （1）空间权衡
- 索引以**B树（平衡树）** 结构存储，需占用额外磁盘空间。
- 存储逻辑：复制目标列数据→排序→通过指针关联原表行（如电影标题索引按字母排序，指向原表电影ID）。
- 代价：多列索引、全表索引会显著增加数据库体积（如`movies.db`索引占比可达30%+）。

#### （2）时间权衡
- 索引仅优化“查询”，会降低“插入/更新/删除”操作的效率。
- 原因：每次修改数据时，需同步维护索引的B树结构（重新排序、调整指针），数据量越大，维护成本越高。

### 5. 部分索引（Partial Index）
- 定义：仅对表中**部分满足条件的行**创建索引，兼顾查询效率与空间占用。
- 适用场景：用户仅频繁查询某类数据（如仅关注2023年新电影）。
- 语法示例：创建2023年电影的标题索引：
  ```sql
  CREATE INDEX "recents_index" ON "movies" ("title") WHERE "year" = 2023;
  ```
- 验证：查询2023年电影时，`EXPLAIN QUERY PLAN`显示使用部分索引，未匹配行的查询仍走全表扫描。

## 三、数据库空间清理：Vacuum
### 1. 核心问题
- SQLite删除数据（如DROP INDEX、DELETE行）时，不会立即释放磁盘空间，仅标记该空间为“可用”，导致数据库体积虚大。

### 2. Vacuum命令作用
- 清理数据库中未使用的空间（标记为可用的删除数据），压缩数据库体积。
- 操作步骤：
  1. 查看数据库当前大小（Unix命令）：`du -b movies.db`（如158MB）。
  2. 删除无用索引：`DROP INDEX "person_index";`。
  3. 执行压缩：`VACUUM;`（耗时几秒到几十秒，取决于数据量）。
  4. 再次查看大小：体积显著减小（如降至100MB）。

### 3. 关键说明
- Vacuum后，已删除的数据（如索引、标记为删除的行）无法恢复（彻底释放空间）。
- 压缩速度取决于未使用空间大小和数据碎片程度，无固定优化方法。

## 四、并发处理：事务与锁机制
### 1. 并发定义
- 多个用户/程序同时对数据库执行查询或修改操作（如多人同时转账、多用户查询电影数据）。
- 核心挑战：避免数据不一致（如银行转账时“扣款成功但收款失败”）。

### 2. 事务（Transaction）
- 定义：数据库中**不可分割的最小操作单元**，要么全部执行，要么全部回滚，确保数据一致性。
- ACID特性（事务核心保障）：
  | 特性 | 描述 |
  |------|------|
  | 原子性（Atomicity） | 事务不可拆分，要么全执行，要么全回滚（如转账时“扣款+收款”要么都成功，要么都失败） |
  | 一致性（Consistency） | 事务执行后，数据库约束不被破坏（如银行账户余额不能为负数） |
  | 隔离性（Isolation） | 多个事务并发执行时，互不干扰（一个事务未结束，其他事务看不到中间状态） |
  | 持久性（Durability） | 事务提交后，数据修改永久生效（即使数据库崩溃，数据也不会丢失） |

### 3. 事务语法
```sql
BEGIN TRANSACTION;  -- 开启事务
-- 事务内操作（可多个UPDATE/INSERT/DELETE）
UPDATE "accounts" SET "balance" = "balance" + 10 WHERE "id" = 2;  -- Bob收款
UPDATE "accounts" SET "balance" = "balance" - 10 WHERE "id" = 1;  -- Alice扣款
COMMIT;  -- 提交事务（所有操作生效）
-- 若执行失败，执行：ROLLBACK;  -- 回滚事务（恢复到事务前状态）
```
- 示例：Alice向Bob转账10元：
  - 正常执行：`COMMIT`后，Alice余额-10，Bob余额+10。
  - 异常执行（如Alice余额不足导致扣款失败）：`ROLLBACK`后，双方余额恢复原状，无数据不一致。

### 4. 竞态条件（Race Conditions）
- 定义：多个事务同时访问共享数据，因执行顺序不确定导致数据不一致（如黑客利用并发漏洞重复转账）。
- 解决方式：数据库锁机制（SQLite通过锁保证事务隔离性）。

### 5. 锁机制（SQLite）
SQLite通过锁控制并发访问，表的锁状态分为三类：
| 锁状态 | 作用 | 并发允许 |
|--------|------|----------|
| UNLOCKED（未锁定） | 无事务访问时的默认状态 | - |
| SHARED（共享锁） | 事务仅读取数据（如查询余额） | 允许其他事务同时读取 |
| EXCLUSIVE（排他锁） | 事务修改数据（如转账、更新） | 禁止其他事务读取或修改（需等待锁释放） |
- 关键规则：
  - 读取操作获取共享锁，写入操作获取排他锁。
  - 排他锁优先级高于共享锁，获取排他锁时需等待所有共享锁释放。
  - SQLite默认锁粒度为“整个数据库”（粗粒度锁），可通过`BEGIN EXCLUSIVE TRANSACTION;`手动开启排他事务。

## 五、关键问题与注意事项
1. **索引创建原则**：不建议为所有列创建索引，仅为频繁查询的列（如电影标题、演员姓名）创建，平衡查询与写入效率。
2. **索引与Schema**：索引会被写入数据库Schema，可通过`.schema`查看所有索引定义。
3. **Vacuum的局限性**：无法加速查询，仅用于清理空间；压缩时数据库不可写入（需等待事务完成）。
4. **事务的必要性**：所有多步修改操作（如转账、订单创建）必须用事务包裹，避免中间状态导致的数据不一致。
5. **SQLite锁的粒度**：SQLite默认锁定整个数据库，高并发写入场景（如秒杀系统）需选择MySQL/PostgreSQL等支持行级锁的DBMS。
6. **覆盖索引的设计**：跨表查询时，将“查询条件列+结果列”纳入索引，最大化查询效率。
